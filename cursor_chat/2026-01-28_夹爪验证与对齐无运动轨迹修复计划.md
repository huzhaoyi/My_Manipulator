# 夹爪闭合验证与对齐无运动轨迹修复计划

## 重点关注的 2 个问题

### 问题 1：夹爪闭合“验证未达目标”但仍按成功处理

**现象**：日志出现 `夹爪闭合验证未达目标: 目标(1.010, -1.010), 实际(-1.010, 1.010)...；控制器已成功，按成功处理（若为 Fake/仿真，joint_states 可能未更新）`，FSM 仍进入 LIFT。

**根因**：
- `close()` 在控制器返回 SUCCEEDED 后做一次验证（pos 与 target 误差），若超容差只打 WARN，仍 `return true`。
- Action 结束 ≠ 夹爪真实到位（尤其真机夹爪慢、带负载、滑差时）。可靠完成条件应是 **joint_state 的 pos/vel 收敛**，而不是仅看 action 结果。
- 若真机也走“验证未达目标仍按成功处理”这条路径，就会造成夹爪没到位也当成功，机械臂提前抬升。

**当前逻辑位置**：
- [gripper_controller.cpp](src/m5_grasp/src/execution/gripper_controller.cpp)：`closeToWidth()` 内验证失败时仅 `LOG_NAMED_WARN`，不 `return false`。
- [grasp_fsm.cpp](src/m5_grasp/src/fsm/grasp_fsm.cpp)：`handleWaitGripper()` 中闭合等待超时后直接 `transitionTo(LIFT)`，未区分“到位”与“超时未到位”。

---

### 问题 2：对齐阶段“轨迹 duration=0，修复后时长=5s，仅 2 点且首尾相同”

**现象**：CHOMP 规划出的 align 轨迹几乎不动（首尾一致），经“轨迹修复/稀疏化”后变成 2 个点、首尾相同、总时长被拉到 5s，执行时“看起来在执行、实际可能没动”。

**根因**：
- 对齐任务只固定 Joint4，若目标 Joint4 已在当前值附近（或 FixedState 种子与当前一致），CHOMP 会给出 101 点、duration=0 的“无运动”轨迹。
- `fixTrajectoryTimestamps`：当相邻点 diff≈0 时用 `MIN_SEGMENT_TIME=0.05s`，101 点 → 总时长约 5s；再经稀疏化（步长 10°）后仅保留首尾 2 点且首尾相同。
- 结果：下发一条“5s 内保持不动”的轨迹，既浪费 5s，又容易让上层误以为在执行。

**当前逻辑位置**：
- [task_runner.cpp](src/m5_grasp/src/mtc/task_runner.cpp)：`fixTrajectoryTimestamps()` 用 `MIN_SEGMENT_TIME` 和 `min_traj_time` 拉长时长；稀疏化只按关节步长过滤，不区分“无运动”轨迹。

---

## 修复策略（最短、最有效）

### 1) 夹爪闭合：以 joint_state 到位为准，验证失败不按成功处理

**原则**：FSM 用 **joint_state 收敛** 判定夹爪完成，不单靠 action 结束；验证未达目标时不应视为成功。

**具体改动**：

| 项目 | 文件 | 修改要点 |
|------|------|----------|
| **A. 验证未达目标时 close() 返回 false** | `src/m5_grasp/src/execution/gripper_controller.cpp` | 在 `closeToWidth()` 中，当 `error_gl > tolerance \|\| error_gr > tolerance` 时不再“仅告警仍 return true”，改为 **return false**，让 FSM 走“闭合失败”分支（如 ABORT_SAFE 或重试）。仿真/Fake 下若需保留“控制器成功即成功”，可加参数 `allow_close_without_verification`（默认 false，真机必须验证）。 |
| **B. WAIT_GRIPPER 闭合超时 → 失败分支** | `src/m5_grasp/src/fsm/grasp_fsm.cpp` | 在 `handleWaitGripper()` 中，当 **等待闭合**（`!wait_gripper_open_ && !wait_gripper_abort_`）且 **超时** 时，不要 `transitionTo(LIFT)`，改为进入 **夹爪闭合失败/抓取不确定** 分支（例如 `transitionTo(ABORT_SAFE)` 或新增 `GRASP_UNCERTAIN`，并清理当前目标）。可保留“最大等待时长”如 6~10s，超时即失败。 |
| **C.（可选）闭合完成条件加速度判据** | `src/m5_grasp/src/execution/gripper_controller.cpp` | `isClosedToTarget(tolerance_rad)` 若仅看 pos，可在真机支持时增加：`|vel| < vel_tol` 连续 N 次采样，再判定到位，减少“还在动就判到位”的误判。 |

**注意**：若关闭“按成功处理”后，在 Fake/仿真下 joint_states 长期不更新会导致每次闭合都失败，需通过参数或环境区分：真机必须验证到位；仿真可配置为“允许仅凭 action 成功即成功”。

---

### 2) 对齐阶段：识别“无运动”轨迹，避免 5s 空执行

**原则**：若轨迹首尾一致（或关节变化量可忽略），应视为“无需执行”或“瞬时完成”，不应拉成 5s 再下发。

**具体改动**：

| 项目 | 文件 | 修改要点 |
|------|------|----------|
| **A. 轨迹修复前/后检测“无运动”** | `src/m5_grasp/src/mtc/task_runner.cpp` | 在 `fixTrajectoryTimestamps()` 或稀疏化之后：对每条子轨迹计算首尾关节位置差 max\|first - last\|；若小于阈值（如 1e-4 rad 或 0.01°），则视为 **无运动轨迹**。 |
| **B. 无运动轨迹缩短时长** | 同上 | 对无运动轨迹：将 **总时长设为极小值**（如 0.1s），即只保留首尾 2 点且 `time_from_start` 末点=0.1s，避免 5s 空跑；或在该 stage 层 **跳过下发、直接视为执行成功**（由上层 result_callback 直接返回成功）。推荐先做“缩短时长”，逻辑简单、与现有执行链路兼容。 |
| **C.（可选）align 阶段跳过已对齐** | `src/m5_grasp/src/mtc/task_runner.cpp` 或 FSM | 在执行 align 前：若当前 Joint4 与目标 Joint4 差已小于某阈值（如 2°），可直接不调用 MTC align、直接报告 align 成功进入下一阶段，从源头上避免生成无运动轨迹。 |

**常量**：当前 `MIN_ARM_TRAJECTORY_TIME = 1.0`，但 101 点×0.05s=5.05s 来自 `MIN_SEGMENT_TIME` 的累加。无运动时应在检测到首尾一致后，强制将整段时长覆盖为 0.1s（或单点 0s），不再用 5s。

---

## 实施顺序建议

1. **夹爪**：先做 A（验证失败 return false）和 B（闭合超时进失败分支），保证真机不会“未闭合就抬升”；再按需加参数区分仿真/真机。
2. **对齐**：先做 A+B（检测无运动 + 缩短时长），消除“5s 空执行”；再按需做 C（已对齐则跳过 align）。

---

## 涉及文件与符号

| 问题 | 文件 | 函数/位置 |
|------|------|------------|
| 夹爪验证 | `src/m5_grasp/src/execution/gripper_controller.cpp` | `closeToWidth()`：验证失败时 return false |
| 夹爪超时 | `src/m5_grasp/src/fsm/grasp_fsm.cpp` | `handleWaitGripper()`：闭合超时 → ABORT_SAFE 或失败分支 |
| 无运动检测 | `src/m5_grasp/src/mtc/task_runner.cpp` | `fixTrajectoryTimestamps()` 或其后：首尾位置差 < 阈值 → 无运动 |
| 无运动时长 | 同上 | 无运动轨迹：总时长设为 0.1s（或跳过执行） |

---

## 与之前计划的衔接

- **ALIGN CHOMP 碰撞（yaw=90° 报 not collision free）**：仍按此前方案在 `makeAlign` 中增加臂-缆绳 ACM（与 makeDescend 一致），或 align 改用 JointInterpolationPlanner。
- **rosout “Publisher already registered”**：维持现状或懒加载 TaskFactory，非本次重点。
- 本计划专注：**夹爪闭合不以“验证未达目标仍成功”放行**，以及 **对齐无运动轨迹不拉成 5s 执行**。
