<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S3æœºæ¢°è‡‚æ¨¡æ‹Ÿå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // STLLoader (å†…è”ç‰ˆæœ¬ï¼Œå…¼å®¹Three.js r128)
        class STLLoader {
            constructor(manager) {
                this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            }
            
            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(scope.manager);
                loader.setResponseType('arraybuffer');
                loader.setPath(scope.path);
                loader.load(url, function(buffer) {
                    try {
                        onLoad(scope.parse(buffer));
                    } catch (e) {
                        if (onError) {
                            onError(e);
                        } else {
                            console.error(e);
                        }
                        scope.manager.itemError(url);
                    }
                }, onProgress, onError);
            }
            
            parse(data) {
                const reader = new DataView(data);
                const faces = reader.getUint32(80, true);
                let r, g, b, hasColors = false, colors;
                let defaultR, defaultG, defaultB;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é¢œè‰²ä¿¡æ¯
                const offset = 80 + 4 + 32 * faces;
                if (offset === reader.byteLength) {
                    hasColors = true;
                    colors = new Float32Array(faces * 3 * 3);
                    defaultR = reader.getUint8(80 + 4 + 32 * faces + 0) / 255;
                    defaultG = reader.getUint8(80 + 4 + 32 * faces + 1) / 255;
                    defaultB = reader.getUint8(80 + 4 + 32 * faces + 2) / 255;
                }
                
                const dataOffset = 84;
                const faceLength = 12 * 4 + 2;
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                
                for (let face = 0; face < faces; face++) {
                    const start = dataOffset + face * faceLength;
                    const normalX = reader.getFloat32(start, true);
                    const normalY = reader.getFloat32(start + 4, true);
                    const normalZ = reader.getFloat32(start + 8, true);
                    
                    for (let i = 1; i <= 3; i++) {
                        const vertexstart = start + i * 12;
                        vertices.push(reader.getFloat32(vertexstart, true));
                        vertices.push(reader.getFloat32(vertexstart + 4, true));
                        vertices.push(reader.getFloat32(vertexstart + 8, true));
                        normals.push(normalX, normalY, normalZ);
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                if (hasColors) {
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                }
                
                return geometry;
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            background-image: 
                linear-gradient(135deg, #0f1419 0%, #1a1f2a 100%);
            color: #e0e0e0;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* å·¦ä¾§ï¼šå…³èŠ‚å€¼æ˜¾ç¤º */
        .left-panel {
            width: 280px;
            background: rgba(15, 20, 40, 0.85);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0, 255, 255, 0.2);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
        }
        
        /* ä¸­é—´ï¼š3Dæœºæ¢°è‡‚æ˜¾ç¤º */
        .viewer {
            flex: 1;
            position: relative;
            background: #0f1419;
            border-left: 1px solid rgba(100, 120, 140, 0.15);
            border-right: 1px solid rgba(100, 120, 140, 0.15);
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        /* å³ä¾§ï¼šæ§åˆ¶ç•Œé¢ */
        .right-panel {
            width: 350px;
            background: rgba(20, 25, 35, 0.9);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(100, 120, 140, 0.15);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: #a0b8c8;
            margin-bottom: 20px;
            font-size: 24px;
            text-align: center;
            text-shadow: none;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .status-box {
            background: rgba(15, 20, 28, 0.7);
            border: 1px solid rgba(100, 120, 140, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .status-box h3 {
            color: #a0b8c8;
            margin-bottom: 12px;
            font-size: 16px;
            text-shadow: none;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(100, 120, 140, 0.1);
            transition: all 0.3s;
        }
        
        .status-item:hover {
            background: rgba(100, 120, 140, 0.05);
            padding-left: 5px;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            font-weight: 500;
            color: #b0b0b0;
        }
        
        .status-value {
            color: #a0b8c8;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            text-shadow: none;
        }
        
        .connection-status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            border: 1px solid;
            transition: all 0.3s;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.15);
            border-color: rgba(76, 175, 80, 0.4);
            color: #81c784;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.15);
            border-color: rgba(244, 67, 54, 0.4);
            color: #e57373;
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);
        }
        
        .info-box {
            background: rgba(15, 20, 28, 0.7);
            border: 1px solid rgba(100, 120, 140, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin-top: 20px;
            font-size: 12px;
            color: #b0b0b0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .info-box strong {
            color: #a0b8c8;
            text-shadow: none;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb {
            background: rgba(100, 120, 140, 0.3);
            border-radius: 4px;
        }
        
        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 120, 140, 0.5);
        }
        
        /* LOGOæ ·å¼ */
        .logo-container {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px 15px;
            border-bottom: 1px solid rgba(100, 120, 140, 0.15);
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid rgba(100, 120, 140, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .logo-container img {
            max-width: 100%;
            height: auto;
            max-height: 80px;
            display: block;
            margin: 0 auto;
            /* æŸ”å’Œçš„èƒŒæ™¯ */
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            /* ç§»é™¤å¼ºçƒˆçš„æ»¤é•œæ•ˆæœï¼Œä¿æŒLOGOåŸå§‹é¢œè‰² */
            filter: none;
            transition: all 0.3s;
            opacity: 0.95;
        }
        
        .logo-container img:hover {
            opacity: 1;
            transform: scale(1.02);
            background: rgba(255, 255, 255, 0.08);
        }
        
        /* é¡¶éƒ¨LOGOï¼ˆå¯é€‰ï¼‰ */
        .top-logo {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            max-height: 50px;
            /* æŸ”å’Œçš„èƒŒæ™¯ï¼Œæ ¹æ®LOGOé¢œè‰²è°ƒæ•´ */
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 15px;
            border-radius: 8px;
            /* ç§»é™¤è¾¹æ¡†å’Œå¼ºçƒˆå‘å…‰ */
            border: none;
            box-shadow: none;
            /* ç§»é™¤å¼ºçƒˆçš„æ»¤é•œæ•ˆæœï¼Œä¿æŒLOGOåŸå§‹é¢œè‰² */
            filter: none;
            opacity: 0.95;
            transition: opacity 0.3s;
        }
        
        .top-logo:hover {
            opacity: 1;
        }
        
        .control-box {
            background: rgba(15, 20, 28, 0.7);
            border: 1px solid rgba(100, 120, 140, 0.2);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .control-box h3 {
            margin-bottom: 15px;
            color: #a0b8c8;
            text-shadow: none;
            font-size: 18px;
        }
        
        .input-group {
            margin-bottom: 12px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #b0b0b0;
            font-size: 13px;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px;
            background: rgba(10, 15, 22, 0.8);
            border: 1px solid rgba(100, 120, 140, 0.3);
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            color: #a0b8c8;
            transition: all 0.3s;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #a0b8c8;
            box-shadow: 0 0 8px rgba(160, 184, 200, 0.2);
            background: rgba(15, 20, 28, 0.9);
        }
        
        .input-row {
            display: flex;
            gap: 10px;
        }
        
        .input-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #6b8ca8 0%, #4a6b85 100%);
            color: #ffffff;
            border: 1px solid rgba(100, 120, 140, 0.4);
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #7a9cb8 0%, #5a7b95 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .btn-secondary {
            background: rgba(100, 100, 100, 0.3);
            color: #b0b0b0;
            border: 1px solid rgba(150, 150, 150, 0.3);
        }
        
        .btn-secondary:hover {
            background: rgba(120, 120, 120, 0.4);
            border-color: rgba(200, 200, 200, 0.5);
        }
        
        .message-box {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }
        
        .message-success {
            background: rgba(76, 175, 80, 0.15);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.15);
        }
        
        .message-error {
            background: rgba(244, 67, 54, 0.15);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
            box-shadow: 0 2px 6px rgba(244, 67, 54, 0.15);
        }
        
        .toggle-advanced {
            margin-top: 10px;
            font-size: 12px;
            color: #a0b8c8;
            cursor: pointer;
            text-decoration: underline;
            text-shadow: none;
            transition: all 0.3s;
        }
        
        .toggle-advanced:hover {
            color: #c0d0e0;
        }
        
        .advanced-controls {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(100, 120, 140, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§ï¼šå…³èŠ‚å€¼æ˜¾ç¤º -->
        <div class="left-panel">
            
            <h1>ğŸ“Š å…³èŠ‚çŠ¶æ€</h1>
            
            <div class="connection-status" id="connectionStatus">
                <span id="statusText">è¿æ¥ä¸­...</span>
            </div>
            
            <div class="status-box">
                <h3>å…³èŠ‚è§’åº¦</h3>
                <div id="joint-values-container">
                    <!-- å¦‚æœæ”¶åˆ°æ•°æ®ï¼Œæ˜¾ç¤ºå…³èŠ‚å€¼ -->
                    <div id="joint-values" style="display: none;">
                        <div class="status-item">
                            <span class="status-label">Joint 1:</span>
                            <span class="status-value" id="axis1-value">0.0Â°</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Joint 2:</span>
                            <span class="status-value" id="axis2-value">0.0Â°</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Joint 3:</span>
                            <span class="status-value" id="axis3-value">0.0Â°</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Joint 4:</span>
                            <span class="status-value" id="axis4-value">0.0Â°</span>
                        </div>
                    </div>
                    <!-- å¦‚æœæœªæ”¶åˆ°æ•°æ®ï¼Œæ˜¾ç¤ºæç¤º -->
                    <div id="no-data-message" class="status-item" style="color: #e57373; font-style: italic; text-shadow: none;">
                        <span>â³ æœªæ”¶åˆ°æœºæ¢°è‡‚æ•°æ®</span>
                    </div>
                </div>
            </div>
            
            <div class="status-box">
                <h3>ç³»ç»ŸçŠ¶æ€</h3>
                <div class="status-item">
                    <span class="status-label">ç¡¬ä»¶çŠ¶æ€:</span>
                    <span class="status-value" id="robot-status">æ­£å¸¸</span>
                </div>
                <div class="status-item">
                    <span class="status-label">è¿è¡ŒçŠ¶æ€:</span>
                    <span class="status-value" id="robot-state">ç©ºé—²</span>
                </div>
            </div>
        </div>
        
        <!-- ä¸­é—´ï¼š3Dæœºæ¢°è‡‚æ˜¾ç¤º -->
        <div class="viewer">
            <img src="SEALIEN-LOGO.png" alt="SEALIEN" class="top-logo" 
                 onerror="console.error('é¡¶éƒ¨LOGOåŠ è½½å¤±è´¥ï¼Œè·¯å¾„:', this.src); this.style.display='none';"
                 onload="console.log('é¡¶éƒ¨LOGOåŠ è½½æˆåŠŸ')">
            <canvas id="canvas"></canvas>
        </div>
        
        <!-- å³ä¾§ï¼šæ§åˆ¶ç•Œé¢ -->
        <div class="right-panel">
            <h1>ğŸ® æ§åˆ¶é¢æ¿</h1>
            
            <div class="control-box">
                <h3>åæ ‡ä¸‹å‘</h3>
                <div class="input-group">
                    <label>ä½ç½® X (m):</label>
                    <input type="number" id="pose-x" step="0.001" value="0.25" placeholder="0.25">
                </div>
                <div class="input-row">
                    <div class="input-group">
                        <label>ä½ç½® Y (m):</label>
                        <input type="number" id="pose-y" step="0.001" value="0.0" placeholder="0.0">
                    </div>
                    <div class="input-group">
                        <label>ä½ç½® Z (m):</label>
                        <input type="number" id="pose-z" step="0.001" value="0.35" placeholder="0.35">
                    </div>
                </div>
                
                <div class="toggle-advanced" onclick="toggleAdvanced()">
                    <span id="toggle-text">æ˜¾ç¤ºé«˜çº§é€‰é¡¹ (Orientation)</span>
                </div>
                
                <div class="advanced-controls" id="advanced-controls">
                    <div class="input-row">
                        <div class="input-group">
                            <label>Orientation QX:</label>
                            <input type="number" id="pose-qx" step="0.001" value="0.0" placeholder="0.0">
                        </div>
                        <div class="input-group">
                            <label>Orientation QY:</label>
                            <input type="number" id="pose-qy" step="0.001" value="0.0" placeholder="0.0">
                        </div>
                    </div>
                    <div class="input-row">
                        <div class="input-group">
                            <label>Orientation QZ:</label>
                            <input type="number" id="pose-qz" step="0.001" value="0.0" placeholder="0.0">
                        </div>
                        <div class="input-group">
                            <label>Orientation QW:</label>
                            <input type="number" id="pose-qw" step="0.001" value="1.0" placeholder="1.0">
                        </div>
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="btn-primary" onclick="publishPose()">å‘å¸ƒä½å§¿</button>
                    <button class="btn-secondary" onclick="resetPose()">é‡ç½®</button>
                </div>
                
                <div class="message-box" id="pose-message"></div>
            </div>
            
            <div class="info-box">
                <strong>ä½¿ç”¨è¯´æ˜:</strong><br>
                â€¢ æ¥æ”¶æœºæ¢°è‡‚JSONåé¦ˆ (UDPç«¯å£7001)<br>
                â€¢ å‘é€åæ ‡åˆ° /target_pose è¯é¢˜<br>
                â€¢ å®æ—¶æ˜¾ç¤ºè§„åˆ’/æ‰§è¡ŒçŠ¶æ€<br>
                â€¢ è‡ªåŠ¨åŠ è½½STLæ¨¡å‹
            </div>
        </div>
    </div>

    <script>
        // Three.jsåœºæ™¯è®¾ç½®
        let scene, camera, renderer, robot;
        let axes = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
        let stlLoader = null;
        let useSTLModel = false;
        let stlModelLoaded = false;
        let urdfData = null;
        let linkMeshes = {}; // å­˜å‚¨æ¯ä¸ªlinkçš„meshå¯¹è±¡
        let linkGroups = {}; // å­˜å‚¨æ¯ä¸ªlinkçš„groupå¯¹è±¡ï¼ˆç”¨äºå˜æ¢ï¼‰
        let jointMap = {}; // å­˜å‚¨jointä¿¡æ¯ï¼Œkeyä¸ºchild link name
        
        // åæ ‡ç³»è½¬æ¢ï¼šROS/URDFåæ ‡ç³» â†’ Three.jsåæ ‡ç³»
        // æ ¹æ®workspace_reachable_positions.mdï¼š
        //   ROS/URDFåæ ‡ç³»ï¼ˆå³æ‰‹ç³»ï¼‰ï¼š
        //     Xè½´ï¼šå‰ï¼ˆforwardï¼‰
        //     Yè½´ï¼šå·¦ï¼ˆleftï¼‰
        //     Zè½´ï¼šä¸Šï¼ˆupï¼‰
        // Three.jsåæ ‡ç³»ï¼ˆå³æ‰‹ç³»ï¼‰ï¼š
        //   Xè½´ï¼šå³ï¼ˆrightï¼‰
        //   Yè½´ï¼šä¸Šï¼ˆupï¼‰
        //   Zè½´ï¼šå‰ï¼ˆforwardï¼Œæœå‘å±å¹•å¤–ï¼‰
        // è½¬æ¢å…³ç³»ï¼šROSçš„(X,Y,Z) â†’ Three.jsçš„(-Y, Z, X)
        // å®ç°æ–¹æ³•ï¼šä½¿ç”¨æ¬§æ‹‰è§’æ—‹è½¬
        // æ–¹æ¡ˆ1ï¼šç»•Xè½´æ—‹è½¬-90åº¦ï¼Œç„¶åç»•Zè½´æ—‹è½¬-90åº¦
        // æ–¹æ¡ˆ2ï¼šç»•Yè½´æ—‹è½¬90åº¦ï¼Œç„¶åç»•Xè½´æ—‹è½¬90åº¦
        // æ ¹æ®demo_moveit.cppï¼ŒLink2æ²¿Zæ–¹å‘å»¶ä¼¸ï¼Œåœ¨ROSä¸­Zæ˜¯å‘ä¸Š
        // åœ¨Three.jsä¸­ï¼ŒYæ˜¯å‘ä¸Šï¼Œæ‰€ä»¥éœ€è¦å°†ROSçš„Zè½´æ˜ å°„åˆ°Three.jsçš„Yè½´
        // åŒæ—¶ROSçš„Xè½´ï¼ˆå‰ï¼‰éœ€è¦æ˜ å°„åˆ°Three.jsçš„Zè½´ï¼ˆå‰ï¼‰
        // ROSçš„Yè½´ï¼ˆå·¦ï¼‰éœ€è¦æ˜ å°„åˆ°Three.jsçš„-Xè½´ï¼ˆå³çš„ç›¸åæ–¹å‘ï¼‰
        const rosToThreeJsRotation = {
            // å°†ROSåæ ‡ç³»è½¬æ¢ä¸ºThree.jsåæ ‡ç³»
            // ä½¿ç”¨æ¬§æ‹‰è§’ï¼šå…ˆç»•Xè½´æ—‹è½¬-90åº¦ï¼ˆä½¿Zâ†’Yï¼‰ï¼Œå†ç»•Zè½´æ—‹è½¬-90åº¦ï¼ˆä½¿Xâ†’Zï¼ŒYâ†’-Xï¼‰
            x: -Math.PI/2,  // ç»•Xè½´æ—‹è½¬-90åº¦ï¼šROSçš„Zï¼ˆä¸Šï¼‰â†’ Three.jsçš„Yï¼ˆä¸Šï¼‰
            y: 0,
            z: -Math.PI/2   // ç»•Zè½´æ—‹è½¬-90åº¦ï¼šROSçš„Xï¼ˆå‰ï¼‰â†’ Three.jsçš„Zï¼ˆå‰ï¼‰ï¼ŒROSçš„Yï¼ˆå·¦ï¼‰â†’ Three.jsçš„-Xï¼ˆå³çš„ç›¸åï¼‰
        };
        
        function initScene() {
            const canvas = document.getElementById('canvas');
            const width = canvas.parentElement.clientWidth;
            const height = canvas.parentElement.clientHeight;
            
            // åœºæ™¯ï¼ˆé«˜ç§‘æŠ€é£æ ¼èƒŒæ™¯ï¼‰
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // ç›¸æœºï¼ˆè°ƒæ•´ä½ç½®å’Œè§†é‡ï¼Œè®©æœºæ¢°è‡‚å®Œæ•´æ˜¾ç¤ºï¼‰
            camera = new THREE.PerspectiveCamera(60, width / height, 0.01, 1000); // fovè®¾ä¸º60ï¼Œå¹³è¡¡æ˜¾ç¤ºå¤§å°
            camera.position.set(1.2, 1.0, 1.2); // é€‚ä¸­çš„è·ç¦»ï¼Œç¡®ä¿æ¨¡å‹å®Œæ•´æ˜¾ç¤º
            camera.lookAt(0, 0.2, 0); // ç¨å¾®å‘ä¸Šçœ‹ï¼Œè®©æœºæ¢°è‡‚åœ¨è§†é‡ä¸­å¿ƒ
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            
            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // åˆå§‹åŒ–STLåŠ è½½å™¨
            stlLoader = new STLLoader();
            
            // åˆ›å»ºæœºæ¢°è‡‚æ¨¡å‹
            createRobot();
            
            // æ·»åŠ ç½‘æ ¼ï¼ˆæ ¹æ®æ–°é…è‰²è°ƒæ•´ï¼‰
            const gridHelper = new THREE.GridHelper(3, 20, 0x64748b, 0x1e293b); // æŸ”å’Œçš„ç°è‰²ç½‘æ ¼
            gridHelper.position.set(0, 0, 0); // ç¡®ä¿åœ¨åŸç‚¹
            scene.add(gridHelper);
            
            // æ·»åŠ åæ ‡è½´ï¼ˆåœ¨åœºæ™¯ä¸­å¿ƒï¼Œæ›´æ˜æ˜¾ï¼‰
            // æ³¨æ„ï¼šåæ ‡è½´éœ€è¦ä¸æœºæ¢°è‡‚æ¨¡å‹ä½¿ç”¨ç›¸åŒçš„åæ ‡ç³»è½¬æ¢
            // ROS/URDFåæ ‡ç³»ï¼šXå‰ï¼ŒYå·¦ï¼ŒZä¸Š
            // Three.jsåæ ‡ç³»ï¼šXå³ï¼ŒYä¸Šï¼ŒZå‰
            // è½¬æ¢åï¼šROSçš„Xï¼ˆå‰ï¼‰â†’ Three.jsçš„Zï¼ˆå‰ï¼‰ï¼ŒROSçš„Yï¼ˆå·¦ï¼‰â†’ Three.jsçš„-Xï¼ˆå³çš„ç›¸åï¼‰ï¼ŒROSçš„Zï¼ˆä¸Šï¼‰â†’ Three.jsçš„Yï¼ˆä¸Šï¼‰
            const axesSize = 0.8;
            const axesGroup = new THREE.Group();
            
            // ROS Xè½´ï¼ˆçº¢è‰²ï¼‰- å‰ï¼ˆåœ¨Three.jsä¸­å¯¹åº”Zè½´æ­£æ–¹å‘ï¼‰
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, axesSize)
            ]);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 3 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            axesGroup.add(xAxis);
            
            // ROS Yè½´ï¼ˆç»¿è‰²ï¼‰- å·¦ï¼ˆåœ¨Three.jsä¸­å¯¹åº”-Xè½´æ–¹å‘ï¼Œå³Xè½´è´Ÿæ–¹å‘ï¼‰
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-axesSize, 0, 0)
            ]);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x44ff44, linewidth: 3 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            axesGroup.add(yAxis);
            
            // ROS Zè½´ï¼ˆè“è‰²ï¼‰- ä¸Šï¼ˆåœ¨Three.jsä¸­å¯¹åº”Yè½´æ­£æ–¹å‘ï¼‰
            const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, axesSize, 0)
            ]);
            const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x4444ff, linewidth: 3 });
            const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
            axesGroup.add(zAxis);
            
            // æ·»åŠ åæ ‡è½´ç®­å¤´ï¼ˆä½¿ç”¨å°åœ†é”¥ï¼‰
            const arrowLength = 0.1;
            const arrowRadius = 0.02;
            
            // ROS Xè½´ç®­å¤´ï¼ˆå‰æ–¹å‘ï¼ŒThree.jsçš„Zè½´æ­£æ–¹å‘ï¼‰
            const xArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const xArrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
            const xArrow = new THREE.Mesh(xArrowGeometry, xArrowMaterial);
            xArrow.position.set(0, 0, axesSize);
            xArrow.rotation.x = -Math.PI / 2;
            axesGroup.add(xArrow);
            
            // ROS Yè½´ç®­å¤´ï¼ˆå·¦æ–¹å‘ï¼ŒThree.jsçš„-Xè½´æ–¹å‘ï¼‰
            const yArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const yArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
            const yArrow = new THREE.Mesh(yArrowGeometry, yArrowMaterial);
            yArrow.position.set(-axesSize, 0, 0);
            yArrow.rotation.z = Math.PI / 2;
            axesGroup.add(yArrow);
            
            // ROS Zè½´ç®­å¤´ï¼ˆä¸Šæ–¹å‘ï¼ŒThree.jsçš„Yè½´æ­£æ–¹å‘ï¼‰
            const zArrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const zArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff });
            const zArrow = new THREE.Mesh(zArrowGeometry, zArrowMaterial);
            zArrow.position.set(0, axesSize, 0);
            axesGroup.add(zArrow);
            
            // æ·»åŠ åæ ‡è½´æ ‡ç­¾ï¼ˆXã€Yã€Zæ–‡å­—ï¼Œå¯¹åº”ROS/URDFåæ ‡ç³»ï¼‰
            function createAxisLabel(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.15, 0.15, 1); // è°ƒæ•´æ ‡ç­¾å¤§å°
                
                return sprite;
            }
            
            // ROS Xè½´æ ‡ç­¾ï¼ˆå‰æ–¹å‘ï¼‰
            const xLabel = createAxisLabel('X', '#ff4444');
            xLabel.position.set(0, 0, axesSize + 0.15);
            axesGroup.add(xLabel);
            
            // ROS Yè½´æ ‡ç­¾ï¼ˆå·¦æ–¹å‘ï¼‰
            const yLabel = createAxisLabel('Y', '#44ff44');
            yLabel.position.set(-axesSize - 0.15, 0, 0);
            axesGroup.add(yLabel);
            
            // ROS Zè½´æ ‡ç­¾ï¼ˆä¸Šæ–¹å‘ï¼‰
            const zLabel = createAxisLabel('Z', '#4444ff');
            zLabel.position.set(0, axesSize + 0.15, 0);
            axesGroup.add(zLabel);
            
            axesGroup.position.set(0, 0, 0); // ç¡®ä¿åœ¨åŸç‚¹ä¸­å¿ƒ
            scene.add(axesGroup);
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                const width = canvas.parentElement.clientWidth;
                const height = canvas.parentElement.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
            
            // åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        function createRobot() {
            robot = new THREE.Group();
            linkMeshes = {};
            linkGroups = {};
            jointMap = {};
            
            // åŠ è½½URDFå¹¶è§£æï¼Œç„¶ååŠ è½½å¤šlink STLæ¨¡å‹
            loadURDFAndSTLModels();
        }
        
        function loadURDFAndSTLModels() {
            console.log('å¼€å§‹åŠ è½½URDFæ–‡ä»¶...');
            fetch('/api/urdf')
                .then(response => response.text())
                .then(urdfText => {
                    console.log('URDFæ–‡ä»¶åŠ è½½æˆåŠŸ');
                    urdfData = parseURDF(urdfText);
                    console.log('URDFè§£æå®Œæˆï¼Œlinks:', Object.keys(urdfData.links).length, 'joints:', Object.keys(urdfData.joints).length);
                    loadAllSTLModels();
                })
                .catch(error => {
                    console.warn('URDFåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å‡ ä½•ä½“:', error);
                    createDefaultRobot();
                });
        }
        
        function parseURDF(urdfText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(urdfText, 'text/xml');
            
            const links = {};
            const joints = {};
            
            // è§£ææ‰€æœ‰link
            const linkElements = xmlDoc.getElementsByTagName('link');
            for (let i = 0; i < linkElements.length; i++) {
                const link = linkElements[i];
                const linkName = link.getAttribute('name');
                if (!linkName || linkName === 'world_link') continue;
                
                // è·å–visualä¸­çš„meshæ–‡ä»¶
                const visual = link.getElementsByTagName('visual')[0];
                if (visual) {
                    const geometry = visual.getElementsByTagName('geometry')[0];
                    if (geometry) {
                        const mesh = geometry.getElementsByTagName('mesh')[0];
                        if (mesh) {
                            const filename = mesh.getAttribute('filename');
                            if (filename) {
                                // æå–STLæ–‡ä»¶å (package://m5/meshes/base_link.STL -> base_link.STL)
                                const stlName = filename.split('/').pop();
                                links[linkName] = {
                                    name: linkName,
                                    stlFile: stlName,
                                    visualOrigin: parseOrigin(visual.getElementsByTagName('origin')[0])
                                };
                            }
                        }
                    }
                }
            }
            
            // è§£ææ‰€æœ‰joint
            const jointElements = xmlDoc.getElementsByTagName('joint');
            for (let i = 0; i < jointElements.length; i++) {
                const joint = jointElements[i];
                const jointName = joint.getAttribute('name');
                const jointType = joint.getAttribute('type');
                const parent = joint.getElementsByTagName('parent')[0];
                const child = joint.getElementsByTagName('child')[0];
                const axis = joint.getElementsByTagName('axis')[0];
                
                if (parent && child) {
                    const parentLink = parent.getAttribute('link');
                    const childLink = child.getAttribute('link');
                    const origin = parseOrigin(joint.getElementsByTagName('origin')[0]);
                    const axisXYZ = axis ? parseXYZ(axis.getAttribute('xyz')) : [0, 0, 1];
                    
                    joints[childLink] = {
                        name: jointName,
                        type: jointType,
                        parent: parentLink,
                        child: childLink,
                        origin: origin,
                        axis: axisXYZ
                    };
                }
            }
            
            return { links, joints };
        }
        
        function parseOrigin(originElement) {
            if (!originElement) return { xyz: [0, 0, 0], rpy: [0, 0, 0] };
            return {
                xyz: parseXYZ(originElement.getAttribute('xyz') || '0 0 0'),
                rpy: parseXYZ(originElement.getAttribute('rpy') || '0 0 0')
            };
        }
        
        function parseXYZ(xyzString) {
            if (!xyzString) return [0, 0, 0];
            return xyzString.split(' ').map(parseFloat);
        }
        
        function loadAllSTLModels() {
            const links = urdfData.links;
            const linkNames = Object.keys(links);
            let loadedCount = 0;
            const totalLinks = linkNames.length;
            
            if (totalLinks === 0) {
                console.warn('æ²¡æœ‰æ‰¾åˆ°linkï¼Œä½¿ç”¨é»˜è®¤æ¨¡å‹');
                createDefaultRobot();
                return;
            }
            
            console.log(`å¼€å§‹åŠ è½½ ${totalLinks} ä¸ªSTLæ–‡ä»¶...`);
            
            linkNames.forEach(linkName => {
                const link = links[linkName];
                const stlFile = link.stlFile;
                
                stlLoader.load(
                    `/meshes/${stlFile}`,
                    function(geometry) {
                        // STLåŠ è½½æˆåŠŸ
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0x888888,
                            specular: 0x111111,
                            shininess: 200,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        
                        // æ£€æµ‹å•ä½å¹¶ç¼©æ”¾ï¼ˆSTLé€šå¸¸æ˜¯æ¯«ç±³ï¼‰
                        geometry.computeBoundingBox();
                        const size = new THREE.Vector3();
                        geometry.boundingBox.getSize(size);
                        const maxDimension = Math.max(size.x, size.y, size.z);
                        if (maxDimension > 100) {
                            mesh.scale.set(0.001, 0.001, 0.001); // æ¯«ç±³è½¬ç±³
                            geometry.computeBoundingBox(); // é‡æ–°è®¡ç®—è¾¹ç•Œæ¡†
                        }
                        
                        // æ³¨æ„ï¼šä¸è¦è‡ªåŠ¨å±…ä¸­STLæ¨¡å‹ï¼Œå› ä¸ºURDFä¸­å·²ç»å®šä¹‰äº†æ­£ç¡®çš„ä½ç½®
                        // STLæ¨¡å‹åº”è¯¥ä¿æŒå…¶åŸå§‹åæ ‡ç³»ï¼Œä¸URDFå®šä¹‰ä¸€è‡´
                        
                        // åº”ç”¨visual originï¼ˆå¦‚æœæœ‰ï¼‰
                        if (link.visualOrigin) {
                            const origin = link.visualOrigin.xyz;
                            if (origin && (origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0)) {
                                mesh.position.set(origin[0], origin[1], origin[2]);
                            }
                            if (link.visualOrigin.rpy) {
                                const rpy = link.visualOrigin.rpy;
                                if (rpy && (rpy[0] !== 0 || rpy[1] !== 0 || rpy[2] !== 0)) {
                                    mesh.rotation.set(rpy[0], rpy[1], rpy[2]);
                                }
                            }
                        }
                        
                        // æ³¨æ„ï¼šä¸å†å¯¹å•ä¸ªlinkåº”ç”¨æ–¹å‘æ ¡æ­£
                        // åæ ‡ç³»è½¬æ¢å·²ç»åœ¨robot groupçº§åˆ«ç»Ÿä¸€å¤„ç†
                        
                        // åˆ›å»ºlink groupç”¨äºå˜æ¢
                        const linkGroup = new THREE.Group();
                        linkGroup.name = linkName;
                        linkGroup.add(mesh);
                        
                        linkMeshes[linkName] = mesh;
                        linkGroups[linkName] = linkGroup;
                        
                        loadedCount++;
                        console.log(`å·²åŠ è½½ ${linkName}: ${stlFile} (${loadedCount}/${totalLinks})`);
                        
                        if (loadedCount === totalLinks) {
                            // æ‰€æœ‰STLåŠ è½½å®Œæˆï¼Œç»„è£…æ¨¡å‹
                            assembleRobotModel();
                        }
                    },
                    function(xhr) {
                        if (xhr.lengthComputable) {
                            const percent = (xhr.loaded / xhr.total) * 100;
                            console.log(`${linkName} åŠ è½½è¿›åº¦: ${percent.toFixed(0)}%`);
                        }
                    },
                    function(error) {
                        console.warn(`åŠ è½½ ${linkName} (${stlFile}) å¤±è´¥:`, error);
                        loadedCount++;
                        if (loadedCount === totalLinks) {
                            if (Object.keys(linkGroups).length > 0) {
                                assembleRobotModel();
                            } else {
                                createDefaultRobot();
                            }
                        }
                    }
                );
            });
        }
        
        function assembleRobotModel() {
            console.log('å¼€å§‹ç»„è£…æœºæ¢°è‡‚æ¨¡å‹...');
            const joints = urdfData.joints;
            const links = urdfData.links;
            
            // åˆ›å»ºlinkçš„å±‚æ¬¡ç»“æ„
            const linkHierarchy = {};
            const rootLinks = [];
            
            // æ‰¾å‡ºæ‰€æœ‰root linksï¼ˆæ²¡æœ‰parentçš„linkï¼‰
            Object.keys(links).forEach(linkName => {
                if (!joints[linkName] || joints[linkName].parent === 'world_link' || joints[linkName].parent === 'base_link') {
                    rootLinks.push(linkName);
                }
            });
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°rootï¼Œä½¿ç”¨base_link
            if (rootLinks.length === 0 && linkGroups['base_link']) {
                rootLinks.push('base_link');
            }
            
            // ä»rootå¼€å§‹é€’å½’æ·»åŠ å­link
            function addLinkToParent(childLinkName, parentGroup) {
                const linkGroup = linkGroups[childLinkName];
                if (!linkGroup) return;
                
                const joint = joints[childLinkName];
                if (joint) {
                    // åº”ç”¨jointçš„originå˜æ¢ï¼ˆä½ç½®å’Œåˆå§‹æ—‹è½¬ï¼‰
                    const origin = joint.origin;
                    if (origin) {
                        linkGroup.position.set(origin.xyz[0], origin.xyz[1], origin.xyz[2]);
                        // åˆå§‹æ—‹è½¬ä¼šåœ¨updateURDFRobotä¸­ä¸å…³èŠ‚è§’åº¦ç»“åˆ
                        if (origin.rpy) {
                            // å­˜å‚¨åˆå§‹æ—‹è½¬ï¼Œä½†ä¸ç›´æ¥è®¾ç½®ï¼ˆå› ä¸ºéœ€è¦ä¸å…³èŠ‚è§’åº¦ç»“åˆï¼‰
                            joint.initialRpy = origin.rpy;
                        }
                    }
                    
                    // å­˜å‚¨jointä¿¡æ¯ç”¨äºåç»­æ›´æ–°
                    jointMap[childLinkName] = joint;
                }
                
                parentGroup.add(linkGroup);
                
                // é€’å½’æ·»åŠ å­link
                Object.keys(joints).forEach(linkName => {
                    if (joints[linkName].parent === childLinkName) {
                        addLinkToParent(linkName, linkGroup);
                    }
                });
            }
            
            // ä»root linkså¼€å§‹ç»„è£…
            rootLinks.forEach(rootLinkName => {
                const rootGroup = linkGroups[rootLinkName];
                if (rootGroup) {
                    robot.add(rootGroup);
                    // æ·»åŠ å­link
                    Object.keys(joints).forEach(linkName => {
                        if (joints[linkName].parent === rootLinkName) {
                            addLinkToParent(linkName, rootGroup);
                        }
                    });
                }
            });
            
            // å¦‚æœbase_linkå­˜åœ¨ï¼Œç¡®ä¿å®ƒæ˜¯root
            if (linkGroups['base_link'] && !rootLinks.includes('base_link')) {
                // æŸ¥æ‰¾base_linkçš„parent
                const baseJoint = Object.values(joints).find(j => j.child === 'base_link');
                if (!baseJoint || baseJoint.parent === 'world_link') {
                    // base_linkåº”è¯¥æ˜¯root
                    if (!robot.children.includes(linkGroups['base_link'])) {
                        robot.add(linkGroups['base_link']);
                        Object.keys(joints).forEach(linkName => {
                            if (joints[linkName].parent === 'base_link') {
                                addLinkToParent(linkName, linkGroups['base_link']);
                            }
                        });
                    }
                }
            }
            
            // åº”ç”¨ROSåˆ°Three.jsçš„åæ ‡ç³»è½¬æ¢
            // ROSåæ ‡ç³»ï¼šXå‰ï¼ŒYå·¦ï¼ŒZä¸Š
            // Three.jsåæ ‡ç³»ï¼šXå³ï¼ŒYä¸Šï¼ŒZå‰
            // è½¬æ¢å…³ç³»ï¼šROSçš„(X,Y,Z) â†’ Three.jsçš„(-Y, Z, X)
            // åœ¨Three.jsä¸­ï¼Œæ¬§æ‹‰è§’çš„æ—‹è½¬é¡ºåºæ˜¯XYZ
            // éœ€è¦å…ˆç»•Zè½´æ—‹è½¬ï¼Œå†ç»•Xè½´æ—‹è½¬
            // ä½†Three.jsçš„rotationæ˜¯ç´¯ç§¯çš„ï¼Œæ‰€ä»¥é¡ºåºå¾ˆé‡è¦
            // å…ˆè®¾ç½®Zè½´æ—‹è½¬ï¼Œå†è®¾ç½®Xè½´æ—‹è½¬
            robot.rotation.z = rosToThreeJsRotation.z;  // å…ˆç»•Zè½´æ—‹è½¬-90åº¦
            robot.rotation.x = rosToThreeJsRotation.x;  // å†ç»•Xè½´æ—‹è½¬-90åº¦
            robot.rotation.y = rosToThreeJsRotation.y;
            
            // ç¨å¾®æ”¾å¤§æœºæ¢°è‡‚æ¨¡å‹ï¼ˆé€‚ä¸­çš„å¤§å°ï¼‰
            robot.scale.set(1.0, 1.0, 1.0); // æ•´ä½“æ”¾å¤§1.2å€ï¼ˆä»1.5æ”¹ä¸º1.2ï¼‰
            
            console.log('åº”ç”¨ROSåˆ°Three.jsåæ ‡ç³»è½¬æ¢:', rosToThreeJsRotation);
            console.log('æœ€ç»ˆæ—‹è½¬è§’åº¦:', {
                x: THREE.MathUtils.radToDeg(robot.rotation.x),
                y: THREE.MathUtils.radToDeg(robot.rotation.y),
                z: THREE.MathUtils.radToDeg(robot.rotation.z)
            });
            console.log('æ¨¡å‹ç¼©æ”¾:', robot.scale);
            
            scene.add(robot);
            stlModelLoaded = true;
            useSTLModel = true;
            console.log('æœºæ¢°è‡‚æ¨¡å‹ç»„è£…å®Œæˆ');
        }
        
        function createDefaultRobot() {
            // åŸºåº§
            const baseGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 32);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.05;
            robot.add(base);
            
            // Link1 (å¯æ—‹è½¬)
            const link1Group = new THREE.Group();
            const link1Geometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
            const link1Material = new THREE.MeshPhongMaterial({ color: 0x667eea });
            const link1 = new THREE.Mesh(link1Geometry, link1Material);
            link1.position.y = 0.2;
            link1Group.add(link1);
            link1Group.name = 'link1';
            robot.add(link1Group);
            
            // Link2
            const link2Group = new THREE.Group();
            link2Group.position.set(0, 0.35, 0);
            const link2Geometry = new THREE.BoxGeometry(0.08, 0.25, 0.08);
            const link2Material = new THREE.MeshPhongMaterial({ color: 0x764ba2 });
            const link2 = new THREE.Mesh(link2Geometry, link2Material);
            link2.position.y = 0.125;
            link2Group.add(link2);
            link2Group.name = 'link2';
            link1Group.add(link2Group);
            
            // Link3
            const link3Group = new THREE.Group();
            link3Group.position.set(0, 0.25, 0);
            const link3Geometry = new THREE.BoxGeometry(0.08, 0.25, 0.08);
            const link3Material = new THREE.MeshPhongMaterial({ color: 0x667eea });
            const link3 = new THREE.Mesh(link3Geometry, link3Material);
            link3.position.y = 0.125;
            link3Group.add(link3);
            link3Group.name = 'link3';
            link2Group.add(link3Group);
            
            // Link4 (æœ«ç«¯)
            const link4Geometry = new THREE.BoxGeometry(0.06, 0.15, 0.06);
            const link4Material = new THREE.MeshPhongMaterial({ color: 0xff6b6b });
            const link4 = new THREE.Mesh(link4Geometry, link4Material);
            link4.position.set(0, 0.25, 0);
            link4.name = 'link4';
            link3Group.add(link4);
            
            scene.add(robot);
        }
        
        function updateRobot() {
            if (!robot) return;
            
            if (useSTLModel && stlModelLoaded && urdfData) {
                // ä½¿ç”¨URDFå¤šlinkæ¨¡å‹ï¼Œæ ¹æ®å…³èŠ‚è§’åº¦æ›´æ–°
                updateURDFRobot();
            } else {
                // ä½¿ç”¨é»˜è®¤å‡ ä½•ä½“æ¨¡å‹
                updateDefaultRobot();
            }
        }
        
        function updateURDFRobot() {
            // æ ¹æ®URDFçš„jointä¿¡æ¯æ›´æ–°æ¯ä¸ªlinkçš„æ—‹è½¬
            // å‚è€ƒdemo_moveit.cppä¸­çš„å¤„ç†æ–¹å¼
            // Joint2å’ŒJoint3çš„èŒƒå›´æ˜¯-1.57åˆ°0ï¼ˆ-90Â°åˆ°0Â°ï¼‰ï¼Œ0åº¦æ—¶åº”è¯¥æ˜¯å‚ç›´å‘ä¸Š
            // æ³¨æ„ï¼šURDFä¸­çš„axiså®šä¹‰çš„æ˜¯æ—‹è½¬è½´æ–¹å‘ï¼Œæ­£è§’åº¦è¡¨ç¤ºç»•è¯¥è½´æ­£æ–¹å‘æ—‹è½¬
            
            function setRotationByAxis(group, axis, angleRad, initialRpy, linkName) {
                if (!group) return;
                
                // è·å–åˆå§‹æ—‹è½¬ï¼ˆæ¥è‡ªjoint originçš„rpyï¼‰
                const baseRpy = initialRpy || [0, 0, 0];
                
                // å…ˆè®¾ç½®åˆå§‹æ—‹è½¬ï¼ˆæ¥è‡ªjoint originï¼‰
                group.rotation.set(baseRpy[0], baseRpy[1], baseRpy[2]);
                
                // ç„¶åæ ¹æ®axisæ·»åŠ å…³èŠ‚è§’åº¦ï¼ˆä½¿ç”¨å¼§åº¦ï¼‰
                // æ³¨æ„ï¼šThree.jsä¸­rotationçš„é¡ºåºæ˜¯XYZï¼ˆæ¬§æ‹‰è§’ï¼‰
                // URDFä¸­axis (1,0,0)è¡¨ç¤ºç»•Xè½´æ­£æ–¹å‘æ—‹è½¬
                // åœ¨Three.jsä¸­ï¼Œç»•Xè½´æ­£æ–¹å‘æ—‹è½¬ä¼šä½¿ç‰©ä½“å‘ä¸‹å€¾æ–œï¼ˆç¬¦åˆå³æ‰‹å®šåˆ™ï¼‰
                // ä½†æ ¹æ®URDFï¼ŒJoint2å’ŒJoint3çš„0åº¦åº”è¯¥æ˜¯å‚ç›´å‘ä¸Šï¼Œæ‰€ä»¥å¯èƒ½éœ€è¦è°ƒæ•´æ–¹å‘
                
                if (Math.abs(axis[2] - 1) < 0.1) {
                    // ç»•Zè½´æ—‹è½¬ï¼ˆæ­£æ–¹å‘ï¼‰
                    group.rotation.z += angleRad;
                } else if (Math.abs(axis[2] + 1) < 0.1) {
                    // ç»•-Zè½´æ—‹è½¬ï¼ˆè´Ÿæ–¹å‘ï¼‰
                    group.rotation.z -= angleRad;
                } else if (Math.abs(axis[0] - 1) < 0.1) {
                    // ç»•Xè½´æ—‹è½¬ï¼ˆæ­£æ–¹å‘ï¼‰
                    // å¯¹äºJoint2å’ŒJoint3ï¼Œéœ€è¦ç¡®ä¿0åº¦æ—¶æ˜¯å‚ç›´çš„
                    // å¦‚æœSTLæ¨¡å‹åˆå§‹æ˜¯å‚ç›´çš„ï¼Œç›´æ¥åŠ ä¸Šè§’åº¦
                    // å¦‚æœSTLæ¨¡å‹åˆå§‹æ˜¯æ°´å¹³çš„ï¼Œéœ€è¦å…ˆæ—‹è½¬-90åº¦ï¼Œå†åŠ ä¸Šè§’åº¦
                    group.rotation.x += angleRad;
                } else if (Math.abs(axis[0] + 1) < 0.1) {
                    // ç»•-Xè½´æ—‹è½¬ï¼ˆè´Ÿæ–¹å‘ï¼‰
                    group.rotation.x -= angleRad;
                } else if (Math.abs(axis[1] - 1) < 0.1) {
                    // ç»•Yè½´æ—‹è½¬ï¼ˆæ­£æ–¹å‘ï¼‰
                    group.rotation.y += angleRad;
                } else if (Math.abs(axis[1] + 1) < 0.1) {
                    // ç»•-Yè½´æ—‹è½¬ï¼ˆè´Ÿæ–¹å‘ï¼‰
                    group.rotation.y -= angleRad;
                }
            }
            
            // å°†è§’åº¦ä»åº¦è½¬æ¢ä¸ºå¼§åº¦
            // Joint1: base_link -> Link1, axis (0, 0, 1), ç»•Zè½´æ—‹è½¬
            const joint1 = jointMap['Link1'];
            if (joint1 && linkGroups['Link1']) {
                const initialRpy = joint1.initialRpy || (joint1.origin ? joint1.origin.rpy : [0, 0, 0]);
                const angleRad = THREE.MathUtils.degToRad(axes[1]);
                setRotationByAxis(linkGroups['Link1'], joint1.axis, angleRad, initialRpy);
            }
            
            // Joint2: Link1 -> Link2, axis (1, 0, 0), ç»•Xè½´æ—‹è½¬
            // èŒƒå›´ï¼š-90Â°åˆ°0Â°ï¼Œ0Â°æ—¶å‚ç›´å‘ä¸Š
            // æ³¨æ„ï¼šå¦‚æœSTLæ¨¡å‹åˆå§‹æ–¹å‘ä¸å¯¹ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´
            const joint2 = jointMap['Link2'];
            if (joint2 && linkGroups['Link2']) {
                const initialRpy = joint2.initialRpy || (joint2.origin ? joint2.origin.rpy : [0, 0, 0]);
                const angleRad = THREE.MathUtils.degToRad(axes[2]);
                // å¦‚æœSTLæ¨¡å‹åˆå§‹æ˜¯æ°´å¹³çš„ï¼Œéœ€è¦å…ˆæ—‹è½¬åˆ°å‚ç›´
                // æ ¹æ®URDFï¼Œaxis (1,0,0)è¡¨ç¤ºç»•Xè½´ï¼Œ0åº¦åº”è¯¥æ˜¯å‚ç›´å‘ä¸Š
                // å¦‚æœSTLæ¨¡å‹åˆå§‹æ²¿Yè½´ï¼ˆæ°´å¹³ï¼‰ï¼Œéœ€è¦å…ˆç»•Xè½´æ—‹è½¬-90åº¦ï¼ˆæˆ–90åº¦ï¼Œå–å†³äºæ¨¡å‹æ–¹å‘ï¼‰
                setRotationByAxis(linkGroups['Link2'], joint2.axis, angleRad, initialRpy, 'Link2');
            }
            
            // Joint3: Link2 -> Link3, axis (1, 0, 0), ç»•Xè½´æ—‹è½¬
            // èŒƒå›´ï¼š-90Â°åˆ°0Â°ï¼Œ0Â°æ—¶å‚ç›´å‘ä¸Š
            const joint3 = jointMap['Link3'];
            if (joint3 && linkGroups['Link3']) {
                const initialRpy = joint3.initialRpy || (joint3.origin ? joint3.origin.rpy : [0, 0, 0]);
                const angleRad = THREE.MathUtils.degToRad(axes[3]);
                setRotationByAxis(linkGroups['Link3'], joint3.axis, angleRad, initialRpy, 'Link3');
            }
            
            // Joint4: Link3 -> Link4, axis (0, 0, 1), ç»•Zè½´æ—‹è½¬
            const joint4 = jointMap['Link4'];
            if (joint4 && linkGroups['Link4']) {
                const initialRpy = joint4.initialRpy || (joint4.origin ? joint4.origin.rpy : [0, 0, 0]);
                const angleRad = THREE.MathUtils.degToRad(axes[4]);
                setRotationByAxis(linkGroups['Link4'], joint4.axis, angleRad, initialRpy);
            }
        }
        
        function updateDefaultRobot() {
            // æ›´æ–°Link1æ—‹è½¬ (Axis 1)
            const link1 = robot.getObjectByName('link1');
            if (link1) {
                link1.rotation.y = THREE.MathUtils.degToRad(axes[1]);
            }
            
            // æ›´æ–°Link2æ—‹è½¬ (Axis 2)
            const link2 = robot.getObjectByName('link2');
            if (link2) {
                link2.rotation.x = THREE.MathUtils.degToRad(axes[2]);
            }
            
            // æ›´æ–°Link3æ—‹è½¬ (Axis 3)
            const link3 = robot.getObjectByName('link3');
            if (link3) {
                link3.rotation.x = THREE.MathUtils.degToRad(axes[3]);
            }
            
            // æ›´æ–°Link4æ—‹è½¬ (Axis 4)
            const link4 = robot.getObjectByName('link4');
            if (link4) {
                link4.rotation.z = THREE.MathUtils.degToRad(axes[4]);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateRobot();
            renderer.render(scene, camera);
        }
        
        // çŠ¶æ€æ›´æ–°
        function updateStatus(data) {
            // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°è¿‡æœºæ¢°è‡‚æ•°æ®
            const hasReceivedData = data.has_received_robot_data || false;
            const jointValuesContainer = document.getElementById('joint-values');
            const noDataMessage = document.getElementById('no-data-message');
            
            if (hasReceivedData) {
                // å·²æ”¶åˆ°æ•°æ®ï¼Œæ˜¾ç¤ºå…³èŠ‚å€¼
                if (jointValuesContainer) jointValuesContainer.style.display = 'block';
                if (noDataMessage) noDataMessage.style.display = 'none';
                
                axes = data.axes || axes;
                
                // æ›´æ–°æ˜¾ç¤º
                for (let i = 1; i <= 4; i++) {
                    const value = axes[i] || 0;
                    const element = document.getElementById(`axis${i}-value`);
                    if (element) {
                        element.textContent = value.toFixed(1) + 'Â°';
                    }
                }
            } else {
                // æœªæ”¶åˆ°æ•°æ®ï¼Œæ˜¾ç¤ºæç¤º
                if (jointValuesContainer) jointValuesContainer.style.display = 'none';
                if (noDataMessage) noDataMessage.style.display = 'block';
            }
            
            // æ›´æ–°ç³»ç»ŸçŠ¶æ€
            const statusElement = document.getElementById('robot-status');
            if (statusElement) {
                // status: -1=æœªçŸ¥, -2=è¶…æ—¶, 0=æ­£å¸¸, å…¶ä»–=å¼‚å¸¸
                let statusText = 'æ­£å¸¸';
                let statusColor = '#a0b8c8'; // é»˜è®¤ä¸»é¢˜è‰²
                
                if (data.status === -1) {
                    statusText = 'æœªçŸ¥';
                    statusColor = '#b0b0b0'; // ç°è‰²
                } else if (data.status === -2) {
                    statusText = 'è¶…æ—¶';
                    statusColor = '#ffb74d'; // æ©™è‰²ï¼ˆè­¦å‘Šï¼‰
                } else if (data.status === 0) {
                    statusText = 'æ­£å¸¸';
                    statusColor = '#81c784'; // ç»¿è‰²
                } else {
                    statusText = 'å¼‚å¸¸';
                    statusColor = '#e57373'; // çº¢è‰²
                }
                
                statusElement.textContent = statusText;
                statusElement.style.color = statusColor;
            }
            
            // æ›´æ–°è¿è¡ŒçŠ¶æ€
            const stateMap = {
                'idle': 'ç©ºé—²',
                'received': 'å·²æ¥æ”¶',
                'planning': 'è§„åˆ’ä¸­',
                'executing': 'æ‰§è¡Œä¸­',
                'rejected': 'å·²æ‹’ç»',
                'invalid': 'æ— æ•ˆ',
                'error': 'é”™è¯¯',
                '__unknown__': 'æœªçŸ¥',
                '__timeout__': 'è¶…æ—¶'
            };
            const robotState = data.robot_state || '__unknown__';
            const stateElement = document.getElementById('robot-state');
            if (stateElement) {
                let stateText = stateMap[robotState] || robotState;
                let stateColor = '#a0b8c8'; // é»˜è®¤ä¸»é¢˜è‰²
                
                // æ ¹æ®çŠ¶æ€æ”¹å˜é¢œè‰²ï¼ˆä½¿ç”¨æŸ”å’Œçš„é…è‰²ï¼‰
                if (robotState === '__unknown__') {
                    stateText = 'æœªçŸ¥';
                    stateColor = '#b0b0b0'; // ç°è‰²
                } else if (robotState === '__timeout__') {
                    stateText = 'è¶…æ—¶';
                    stateColor = '#ffb74d'; // æ©™è‰²ï¼ˆè­¦å‘Šï¼‰
                } else if (robotState === 'received') {
                    stateColor = '#64b5f6'; // æŸ”å’Œçš„è“è‰²
                } else if (robotState === 'planning') {
                    stateColor = '#ffb74d'; // æŸ”å’Œçš„æ©™è‰²
                } else if (robotState === 'executing') {
                    stateColor = '#81c784'; // æŸ”å’Œçš„ç»¿è‰²
                } else if (robotState === 'rejected') {
                    stateColor = '#ffa726'; // æŸ”å’Œçš„æ©™é»„è‰²ï¼ˆè­¦å‘Šï¼‰
                } else if (robotState === 'invalid') {
                    stateColor = '#ef5350'; // æŸ”å’Œçš„çº¢è‰²ï¼ˆè­¦å‘Šï¼‰
                } else if (robotState === 'error') {
                    stateColor = '#e57373'; // æŸ”å’Œçš„çº¢è‰²
                }
                
                stateElement.textContent = stateText;
                stateElement.style.color = stateColor;
            }
        }
        
        // è½®è¯¢çŠ¶æ€
        function pollStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    updateStatus(data);
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('statusText').textContent = 'å·²è¿æ¥';
                })
                .catch(error => {
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('statusText').textContent = 'æœªè¿æ¥';
                });
        }
        
        // åæ ‡ä¸‹å‘åŠŸèƒ½
        function toggleAdvanced() {
            const controls = document.getElementById('advanced-controls');
            const text = document.getElementById('toggle-text');
            if (controls.style.display === 'none' || controls.style.display === '') {
                controls.style.display = 'block';
                text.textContent = 'éšè—é«˜çº§é€‰é¡¹ (Orientation)';
            } else {
                controls.style.display = 'none';
                text.textContent = 'æ˜¾ç¤ºé«˜çº§é€‰é¡¹ (Orientation)';
            }
        }
        
        function publishPose() {
            const x = parseFloat(document.getElementById('pose-x').value);
            const y = parseFloat(document.getElementById('pose-y').value);
            const z = parseFloat(document.getElementById('pose-z').value);
            const qx = parseFloat(document.getElementById('pose-qx').value) || 0.0;
            const qy = parseFloat(document.getElementById('pose-qy').value) || 0.0;
            const qz = parseFloat(document.getElementById('pose-qz').value) || 0.0;
            const qw = parseFloat(document.getElementById('pose-qw').value) || 1.0;
            
            if (isNaN(x) || isNaN(y) || isNaN(z)) {
                showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡å€¼', 'error');
                return;
            }
            
            const data = {
                x: x,
                y: y,
                z: z,
                qx: qx,
                qy: qy,
                qz: qz,
                qw: qw
            };
            
            fetch('/api/publish_pose', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showMessage(result.message, 'success');
                } else {
                    showMessage(result.message || 'å‘å¸ƒå¤±è´¥', 'error');
                }
            })
            .catch(error => {
                showMessage('ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            });
        }
        
        function resetPose() {
            document.getElementById('pose-x').value = '0.25';
            document.getElementById('pose-y').value = '0.0';
            document.getElementById('pose-z').value = '0.35';
            document.getElementById('pose-qx').value = '0.0';
            document.getElementById('pose-qy').value = '0.0';
            document.getElementById('pose-qz').value = '0.0';
            document.getElementById('pose-qw').value = '1.0';
            showMessage('', 'success');
        }
        
        function showMessage(message, type) {
            const messageBox = document.getElementById('pose-message');
            if (!message) {
                messageBox.style.display = 'none';
                return;
            }
            
            messageBox.textContent = message;
            messageBox.className = 'message-box message-' + type;
            messageBox.style.display = 'block';
            
            // 3ç§’åè‡ªåŠ¨éšè—æˆåŠŸæ¶ˆæ¯
            if (type === 'success') {
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 3000);
            }
        }
        
        // åˆå§‹åŒ–
        initScene();
        setInterval(pollStatus, 100); // æ¯100msæ›´æ–°ä¸€æ¬¡çŠ¶æ€
    </script>
</body>
</html>
